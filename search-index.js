var searchIndex={};
searchIndex["rustacuda"] = {"doc":"This crate provides a safe, user-friendly wrapper around…","i":[[3,"CudaFlags","rustacuda","Bit flags for initializing the CUDA driver. Currently, no…",null,null],[3,"CudaApiVersion","","Struct representing the CUDA API version number.",null,null],[5,"init","","Initialize the CUDA Driver API.",null,[[["cudaflags"]],["cudaresult"]]],[5,"quick_init","","Shortcut for initializing the CUDA Driver API and creating…",null,[[],[["cudaresult",["context"]],["context"]]]],[0,"context","","CUDA context management",null,null],[3,"ContextFlags","rustacuda::context","Bit flags for initializing the CUDA context.",null,null],[3,"Context","","Owned handle to a CUDA context.",null,null],[3,"UnownedContext","","Non-owning handle to a CUDA context.",null,null],[3,"ContextStack","","Type used to represent the thread-local context stack.",null,null],[3,"StreamPriorityRange","","Struct representing a range of stream priorities.",null,null],[12,"least","","The least stream priority",0,null],[12,"greatest","","The greatest stream priority",0,null],[3,"CurrentContext","","Type representing the top context in the thread-local stack.",null,null],[4,"CacheConfig","","This enumeration represents configuration settings for…",null,null],[13,"PreferNone","","No preference for shared memory or L1 (default)",1,null],[13,"PreferShared","","Prefer larger shared memory and smaller L1 cache",1,null],[13,"PreferL1","","Prefer larger L1 cache and smaller shared memory",1,null],[13,"PreferEqual","","Prefer equal-sized L1 cache and shared memory",1,null],[4,"ResourceLimit","","This enumeration represents the limited resources which…",null,null],[13,"StackSize","","The size in bytes of each GPU thread stack",2,null],[13,"PrintfFifoSize","","The size in bytes of the FIFO used by the `printf()`…",2,null],[13,"MallocHeapSize","","The size in bytes of the heap used by the `malloc()` and…",2,null],[13,"DeviceRuntimeSynchronizeDepth","","The maximum nesting depth of a grid at which a thread can…",2,null],[13,"DeviceRuntimePendingLaunchCount","","The maximum number of outstanding device runtime launches…",2,null],[13,"MaxL2FetchGranularity","","L2 cache fetch granularity",2,null],[4,"SharedMemoryConfig","","This enumeration represents the options for configuring…",null,null],[13,"DefaultBankSize","","Set shared-memory bank size to the default.",3,null],[13,"FourByteBankSize","","Set shared-memory bank width to four bytes",3,null],[13,"EightByteBankSize","","Set shared-memory bank width to eight bytes",3,null],[8,"ContextHandle","","Sealed trait for `Context` and `UnownedContext`. Not…",null,null],[18,"SCHED_SPIN","","Instructs CUDA to actively spin when waiting for results…",4,null],[18,"SCHED_YIELD","","Instructs CUDA to yield its thread when waiting for…",4,null],[18,"SCHED_BLOCKING_SYNC","","Instructs CUDA to block the CPU thread on a…",4,null],[18,"SCHED_AUTO","","Instructs CUDA to automatically choose whether to yield to…",4,null],[18,"MAP_HOST","","Instructs CUDA to support mapped pinned allocations. This…",4,null],[18,"LMEM_RESIZE_TO_MAX","","Instruct CUDA not to reduce local memory after resizing…",4,null],[11,"empty","","Returns an empty set of flags",4,[[],["contextflags"]]],[11,"all","","Returns the set containing all flags.",4,[[],["contextflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",4,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",4,[[["u32"]],[["contextflags"],["option",["contextflags"]]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",4,[[["u32"]],["contextflags"]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",4,[[["u32"]],["contextflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",4,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",4,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",4,[[["contextflags"],["self"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",4,[[["contextflags"],["self"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",4,[[["self"],["contextflags"]]]],[11,"remove","","Removes the specified flags in-place.",4,[[["self"],["contextflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",4,[[["self"],["contextflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",4,[[["self"],["contextflags"],["bool"]]]],[11,"create_and_push","","Create a CUDA context for the given device.",5,[[["device"],["contextflags"]],[["cudaresult",["context"]],["context"]]]],[11,"get_api_version","","Get the API version used to create this context.",5,[[["self"]],[["cudaresult",["cudaapiversion"]],["cudaapiversion"]]]],[11,"get_unowned","","Returns an non-owning handle to this context.",5,[[["self"]],["unownedcontext"]]],[11,"drop","","Destroy a `Context`, returning an error.",5,[[["context"]],[["context"],["dropresult",["context"]]]]],[11,"get_api_version","","Get the API version used to create this context.",6,[[["self"]],[["cudaresult",["cudaapiversion"]],["cudaapiversion"]]]],[11,"pop","","Pop the current context off the stack and return the…",7,[[],[["unownedcontext"],["cudaresult",["unownedcontext"]]]]],[11,"push","","Push the given context to the top of the stack",7,[[["c"]],["cudaresult"]]],[11,"get_cache_config","","Returns the preferred cache configuration for the current…",8,[[],[["cacheconfig"],["cudaresult",["cacheconfig"]]]]],[11,"get_device","","Return the device ID for the current context.",8,[[],[["cudaresult",["device"]],["device"]]]],[11,"get_flags","","Return the context flags for the current context.",8,[[],[["cudaresult",["contextflags"]],["contextflags"]]]],[11,"get_resource_limit","","Return resource limits for the current context.",8,[[["resourcelimit"]],[["cudaresult",["usize"]],["usize"]]]],[11,"get_shared_memory_config","","Return resource limits for the current context.",8,[[],[["sharedmemoryconfig"],["cudaresult",["sharedmemoryconfig"]]]]],[11,"get_stream_priority_range","","Return the least and greatest stream priorities.",8,[[],[["cudaresult",["streampriorityrange"]],["streampriorityrange"]]]],[11,"set_cache_config","","Sets the preferred cache configuration for the current…",8,[[["cacheconfig"]],["cudaresult"]]],[11,"set_resource_limit","","Sets a requested resource limit for the current context.",8,[[["resourcelimit"],["usize"]],["cudaresult"]]],[11,"set_shared_memory_config","","Sets the preferred shared memory configuration for the…",8,[[["sharedmemoryconfig"]],["cudaresult"]]],[11,"get_current","","Returns a non-owning handle to the current context.",8,[[],[["unownedcontext"],["cudaresult",["unownedcontext"]]]]],[11,"set_current","","Set the given context as the current context for this…",8,[[["c"]],["cudaresult"]]],[11,"synchronize","","Block to wait for a context's tasks to complete.",8,[[],["cudaresult"]]],[0,"device","rustacuda","Functions and types for enumerating CUDA devices and…",null,null],[3,"Device","rustacuda::device","Opaque handle to a CUDA device.",null,null],[3,"Devices","","Iterator over all available CUDA devices. See the…",null,null],[4,"DeviceAttribute","","All supported device attributes for Device::get_attribute",null,null],[13,"MaxThreadsPerBlock","","Maximum number of threads per block",9,null],[13,"MaxBlockDimX","","Maximum x-dimension of a block",9,null],[13,"MaxBlockDimY","","Maximum y-dimension of a block",9,null],[13,"MaxBlockDimZ","","Maximum z-dimension of a block",9,null],[13,"MaxGridDimX","","Maximum x-dimension of a grid",9,null],[13,"MaxGridDimY","","Maximum y-dimension of a grid",9,null],[13,"MaxGridDimZ","","Maximum z-dimension of a grid",9,null],[13,"MaxSharedMemoryPerBlock","","Maximum amount of shared memory available to a thread…",9,null],[13,"TotalConstantMemory","","Memory available on device for constant variables in a…",9,null],[13,"WarpSize","","Warp size in threads",9,null],[13,"MaxPitch","","Maximum pitch in bytes allowed by the memory copy…",9,null],[13,"MaxRegistersPerBlock","","Maximum number of 32-bit registers available to a thread…",9,null],[13,"ClockRate","","Typical clock frequency in kilohertz",9,null],[13,"TextureAlignment","","Alignment requirement for textures",9,null],[13,"MultiprocessorCount","","Number of multiprocessors on device.",9,null],[13,"KernelExecTimeout","","Specifies whether there is a run time limit on kernels",9,null],[13,"Integrated","","Device is integrated with host memory",9,null],[13,"CanMapHostMemory","","Device can map host memory into CUDA address space",9,null],[13,"ComputeMode","","Compute Mode",9,null],[13,"MaximumTexture1DWidth","","Maximum 1D texture width",9,null],[13,"MaximumTexture2DWidth","","Maximum 2D texture width",9,null],[13,"MaximumTexture2DHeight","","Maximum 2D texture height",9,null],[13,"MaximumTexture3DWidth","","Maximum 3D texture width",9,null],[13,"MaximumTexture3DHeight","","Maximum 3D texture height",9,null],[13,"MaximumTexture3DDepth","","Maximum 3D texture depth",9,null],[13,"MaximumTexture2DLayeredWidth","","Maximum 2D layered texture width",9,null],[13,"MaximumTexture2DLayeredHeight","","Maximum 2D layered texture height",9,null],[13,"MaximumTexture2DLayeredLayers","","Maximum layers in a 2D layered texture",9,null],[13,"SurfaceAlignment","","Alignment requirement for surfaces",9,null],[13,"ConcurrentKernels","","Device can possibly execute multiple kernels concurrently",9,null],[13,"EccEnabled","","Device has ECC support enabled",9,null],[13,"PciBusId","","PCI bus ID of the device",9,null],[13,"PciDeviceId","","PCI device ID of the device",9,null],[13,"TccDriver","","Device is using TCC driver model",9,null],[13,"MemoryClockRate","","Peak memory clock frequency in kilohertz",9,null],[13,"GlobalMemoryBusWidth","","Global memory bus width in bits",9,null],[13,"L2CacheSize","","Size of L2 cache in bytes.",9,null],[13,"MaxThreadsPerMultiprocessor","","Maximum resident threads per multiprocessor",9,null],[13,"AsyncEngineCount","","Number of asynchronous engines",9,null],[13,"UnifiedAddressing","","Device shares a unified address space with the host",9,null],[13,"MaximumTexture1DLayeredWidth","","Maximum 1D layered texture width",9,null],[13,"MaximumTexture1DLayeredLayers","","Maximum layers in a 1D layered texture",9,null],[13,"MaximumTexture2DGatherWidth","","Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is…",9,null],[13,"MaximumTexture2DGatherHeight","","Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER…",9,null],[13,"MaximumTexture3DWidthAlternate","","Alternate maximum 3D texture width",9,null],[13,"MaximumTexture3DHeightAlternate","","Alternate maximum 3D texture height",9,null],[13,"MaximumTexture3DDepthAlternate","","Alternate maximum 3D texture depth",9,null],[13,"PciDomainId","","PCI domain ID of the device",9,null],[13,"TexturePitchAlignment","","Pitch alignment requirement for textures",9,null],[13,"MaximumTextureCubemapWidth","","Maximum cubemap texture width/height",9,null],[13,"MaximumTextureCubemapLayeredWidth","","Maximum cubemap layered texture width/height",9,null],[13,"MaximumTextureCubemapLayeredLayers","","Maximum layers in a cubemap layered texture",9,null],[13,"MaximumSurface1DWidth","","Maximum 1D surface width",9,null],[13,"MaximumSurface2DWidth","","Maximum 2D surface width",9,null],[13,"MaximumSurface2DHeight","","Maximum 2D surface height",9,null],[13,"MaximumSurface3DWidth","","Maximum 3D surface width",9,null],[13,"MaximumSurface3DHeight","","Maximum 3D surface height",9,null],[13,"MaximumSurface3DDepth","","Maximum 3D surface depth",9,null],[13,"MaximumSurface1DLayeredWidth","","Maximum 1D layered surface width",9,null],[13,"MaximumSurface1DLayeredLayers","","Maximum layers in a 1D layered surface",9,null],[13,"MaximumSurface2DLayeredWidth","","Maximum 2D layered surface width",9,null],[13,"MaximumSurface2DLayeredHeight","","Maximum 2D layered surface height",9,null],[13,"MaximumSurface2DLayeredLayers","","Maximum layers in a 2D layered surface",9,null],[13,"MaximumSurfacecubemapWidth","","Maximum cubemap surface width",9,null],[13,"MaximumSurfacecubemapLayeredWidth","","Maximum cubemap layered surface width",9,null],[13,"MaximumSurfacecubemapLayeredLayers","","Maximum layers in a cubemap layered surface",9,null],[13,"MaximumTexture1DLinearWidth","","Maximum 1D linear texture width",9,null],[13,"MaximumTexture2DLinearWidth","","Maximum 2D linear texture width",9,null],[13,"MaximumTexture2DLinearHeight","","Maximum 2D linear texture height",9,null],[13,"MaximumTexture2DLinearPitch","","Maximum 2D linear texture pitch in bytes",9,null],[13,"MaximumTexture2DMipmappedWidth","","Maximum mipmapped 2D texture height",9,null],[13,"MaximumTexture2DMipmappedHeight","","Maximum mipmapped 2D texture width",9,null],[13,"ComputeCapabilityMajor","","Major compute capability version number",9,null],[13,"ComputeCapabilityMinor","","Minor compute capability version number",9,null],[13,"MaximumTexture1DMipmappedWidth","","Maximum mipammed 1D texture width",9,null],[13,"StreamPrioritiesSupported","","Device supports stream priorities",9,null],[13,"GlobalL1CacheSupported","","Device supports caching globals in L1",9,null],[13,"LocalL1CacheSupported","","Device supports caching locals in L1",9,null],[13,"MaxSharedMemoryPerMultiprocessor","","Maximum shared memory available per multiprocessor in bytes",9,null],[13,"MaxRegistersPerMultiprocessor","","Maximum number of 32-bit registers available per…",9,null],[13,"ManagedMemory","","Device can allocate managed memory on this system",9,null],[13,"MultiGpuBoard","","Device is on a multi-GPU board",9,null],[13,"MultiGpuBoardGroupId","","Unique ID for a group of devices on the same multi-GPU board",9,null],[13,"HostNativeAtomicSupported","","Link between the device and the host supports native…",9,null],[13,"SingleToDoublePrecisionPerfRatio","","Ratio of single precision performance (in floating-point…",9,null],[13,"PageableMemoryAccess","","Device supports coherently accessing pageable memory…",9,null],[13,"ConcurrentManagedAccess","","Device can coherently access managed memory concurrently…",9,null],[13,"ComputePreemptionSupported","","Device supports compute preemption",9,null],[13,"CanUseHostPointerForRegisteredMem","","Device can access host registered memory at the same…",9,null],[11,"num_devices","","Get the number of CUDA-capable devices.",10,[[],[["cudaresult",["u32"]],["u32"]]]],[11,"get_device","","Get a handle to the `ordinal`'th CUDA device.",10,[[["u32"]],[["cudaresult",["device"]],["device"]]]],[11,"devices","","Return an iterator over all CUDA devices.",10,[[],[["devices"],["cudaresult",["devices"]]]]],[11,"total_memory","","Returns the total amount of memory available on the device…",10,[[],[["cudaresult",["usize"]],["usize"]]]],[11,"name","","Returns the name of this device.",10,[[],[["string"],["cudaresult",["string"]]]]],[11,"get_attribute","","Returns information about this device.",10,[[["deviceattribute"]],[["cudaresult",["i32"]],["i32"]]]],[0,"error","rustacuda","Types for error handling",null,null],[4,"CudaError","rustacuda::error","Error enum which represents all the potential errors…",null,null],[13,"InvalidValue","","",11,null],[13,"OutOfMemory","","",11,null],[13,"NotInitialized","","",11,null],[13,"Deinitialized","","",11,null],[13,"ProfilerDisabled","","",11,null],[13,"ProfilerNotInitialized","","",11,null],[13,"ProfilerAlreadyStarted","","",11,null],[13,"ProfilerAlreadyStopped","","",11,null],[13,"NoDevice","","",11,null],[13,"InvalidDevice","","",11,null],[13,"InvalidImage","","",11,null],[13,"InvalidContext","","",11,null],[13,"ContextAlreadyCurrent","","",11,null],[13,"MapFailed","","",11,null],[13,"UnmapFailed","","",11,null],[13,"ArrayIsMapped","","",11,null],[13,"AlreadyMapped","","",11,null],[13,"NoBinaryForGpu","","",11,null],[13,"AlreadyAcquired","","",11,null],[13,"NotMapped","","",11,null],[13,"NotMappedAsArray","","",11,null],[13,"NotMappedAsPointer","","",11,null],[13,"EccUncorrectable","","",11,null],[13,"UnsupportedLimit","","",11,null],[13,"ContextAlreadyInUse","","",11,null],[13,"PeerAccessUnsupported","","",11,null],[13,"InvalidPtx","","",11,null],[13,"InvalidGraphicsContext","","",11,null],[13,"NvlinkUncorrectable","","",11,null],[13,"InvalidSouce","","",11,null],[13,"FileNotFound","","",11,null],[13,"SharedObjectSymbolNotFound","","",11,null],[13,"SharedObjectInitFailed","","",11,null],[13,"OperatingSystemError","","",11,null],[13,"InvalidHandle","","",11,null],[13,"NotFound","","",11,null],[13,"NotReady","","",11,null],[13,"IllegalAddress","","",11,null],[13,"LaunchOutOfResources","","",11,null],[13,"LaunchTimeout","","",11,null],[13,"LaunchIncompatibleTexturing","","",11,null],[13,"PeerAccessAlreadyEnabled","","",11,null],[13,"PeerAccessNotEnabled","","",11,null],[13,"PrimaryContextActive","","",11,null],[13,"ContextIsDestroyed","","",11,null],[13,"AssertError","","",11,null],[13,"TooManyPeers","","",11,null],[13,"HostMemoryAlreadyRegistered","","",11,null],[13,"HostMemoryNotRegistered","","",11,null],[13,"HardwareStackError","","",11,null],[13,"IllegalInstruction","","",11,null],[13,"MisalignedAddress","","",11,null],[13,"InvalidAddressSpace","","",11,null],[13,"InvalidProgramCounter","","",11,null],[13,"LaunchFailed","","",11,null],[13,"NotPermitted","","",11,null],[13,"NotSupported","","",11,null],[13,"UnknownError","","",11,null],[13,"InvalidMemoryAllocation","","",11,null],[6,"CudaResult","","Result type for most CUDA functions.",null,null],[6,"DropResult","","Special result type for `drop` functions which includes…",null,null],[0,"event","rustacuda","Events can be used to track status and dependencies, as…",null,null],[3,"EventFlags","rustacuda::event","Bit flags for configuring a CUDA Event.",null,null],[3,"Event","","An event to track work submitted to a stream.",null,null],[4,"EventStatus","","Status enum that represents the current status of an event.",null,null],[13,"Ready","","Ready indicates that all work captured by the event has…",12,null],[13,"NotReady","","`EventStatus::NotReady` indicates that the work captured…",12,null],[18,"DEFAULT","","The default event creation flag.",13,null],[18,"BLOCKING_SYNC","","Specify that the created event should busy-wait on…",13,null],[18,"DISABLE_TIMING","","Specify that the created event does not need to record…",13,null],[18,"INTERPROCESS","","Specify that the created event may be used as an…",13,null],[11,"empty","","Returns an empty set of flags",13,[[],["eventflags"]]],[11,"all","","Returns the set containing all flags.",13,[[],["eventflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",13,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",13,[[["u32"]],[["eventflags"],["option",["eventflags"]]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",13,[[["u32"]],["eventflags"]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",13,[[["u32"]],["eventflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",13,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",13,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",13,[[["eventflags"],["self"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",13,[[["eventflags"],["self"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",13,[[["self"],["eventflags"]]]],[11,"remove","","Removes the specified flags in-place.",13,[[["self"],["eventflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",13,[[["self"],["eventflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",13,[[["self"],["eventflags"],["bool"]]]],[11,"new","","Create a new event with the specified flags.",14,[[["eventflags"]],["cudaresult"]]],[11,"record","","Add the event to the given stream of work. The event will…",14,[[["stream"],["self"]],["cudaresult"]]],[11,"query","","Return whether the stream this event was recorded on (see…",14,[[["self"]],[["cudaresult",["eventstatus"]],["eventstatus"]]]],[11,"synchronize","","Wait for an event to complete.",14,[[["self"]],["cudaresult"]]],[11,"elapsed_time_f32","","Return the duration between two events.",14,[[["self"]],[["cudaresult",["f32"]],["f32"]]]],[11,"drop","","Destroy an `Event` returning an error.",14,[[["event"]],[["dropresult",["event"]],["event"]]]],[0,"function","rustacuda","Functions and types for working with CUDA kernels.",null,null],[3,"GridSize","rustacuda::function","Dimensions of a grid, or the number of thread blocks in a…",null,null],[12,"x","","Width of grid in blocks",15,null],[12,"y","","Height of grid in blocks",15,null],[12,"z","","Depth of grid in blocks",15,null],[3,"BlockSize","","Dimensions of a thread block, or the number of threads in…",null,null],[12,"x","","X dimension of each thread block",16,null],[12,"y","","Y dimension of each thread block",16,null],[12,"z","","Z dimension of each thread block",16,null],[3,"Function","","Handle to a global kernel function.",null,null],[4,"FunctionAttribute","","All supported function attributes for…",null,null],[13,"MaxThreadsPerBlock","","The maximum number of threads per block, beyond which a…",17,null],[13,"SharedMemorySizeBytes","","The size in bytes of the statically-allocated shared…",17,null],[13,"ConstSizeBytes","","The size in bytes of the constant memory required by this…",17,null],[13,"LocalSizeBytes","","The size in bytes of local memory used by each thread of…",17,null],[13,"NumRegisters","","The number of registers used by each thread of this function",17,null],[13,"PtxVersion","","The PTX virtual architecture version for which the…",17,null],[13,"BinaryVersion","","The binary architecture version for which the function was…",17,null],[13,"CacheModeCa","","The attribute to indicate whether the function has been…",17,null],[11,"x","","Create a one-dimensional grid of `x` blocks",15,[[["u32"]],["gridsize"]]],[11,"xy","","Create a two-dimensional grid of `x * y` blocks",15,[[["u32"]],["gridsize"]]],[11,"xyz","","Create a three-dimensional grid of `x * y * z` blocks",15,[[["u32"]],["gridsize"]]],[11,"x","","Create a one-dimensional block of `x` threads",16,[[["u32"]],["blocksize"]]],[11,"xy","","Create a two-dimensional block of `x * y` threads",16,[[["u32"]],["blocksize"]]],[11,"xyz","","Create a three-dimensional block of `x * y * z` threads",16,[[["u32"]],["blocksize"]]],[11,"get_attribute","","Returns information about a function.",18,[[["self"],["functionattribute"]],[["cudaresult",["i32"]],["i32"]]]],[11,"set_cache_config","","Sets the preferred cache configuration for this function.",18,[[["self"],["cacheconfig"]],["cudaresult"]]],[11,"set_shared_memory_config","","Sets the preferred shared memory configuration for this…",18,[[["sharedmemoryconfig"],["self"]],["cudaresult"]]],[0,"memory","rustacuda","Access to CUDA's memory allocation and transfer functions.",null,null],[8,"DeviceCopy","rustacuda::memory","Marker trait for types which can safely be copied to or…",null,null],[3,"DevicePointer","","A pointer to device memory.",null,null],[3,"UnifiedPointer","","A pointer to unified memory.",null,null],[3,"DeviceBox","","A pointer type for heap-allocation in CUDA device memory.",null,null],[3,"DeviceBuffer","","Fixed-size device-side buffer. Provides basic access to…",null,null],[3,"DeviceSlice","","Fixed-size device-side slice.",null,null],[3,"DeviceChunks","","An iterator over a `DeviceSlice` in (non-overlapping)…",null,null],[3,"DeviceChunksMut","","An iterator over a `DeviceSlice` in (non-overlapping)…",null,null],[3,"LockedBuffer","","Fixed-size host-side buffer in page-locked memory.",null,null],[3,"UnifiedBox","","A pointer type for heap-allocation in CUDA unified memory.",null,null],[3,"UnifiedBuffer","","Fixed-size buffer in unified memory.",null,null],[5,"cuda_malloc","","Unsafe wrapper around the `cuMemAlloc` function, which…",null,[[["usize"]],[["devicepointer"],["cudaresult",["devicepointer"]]]]],[5,"cuda_malloc_unified","","Unsafe wrapper around the `cuMemAllocManaged` function,…",null,[[["usize"]],[["cudaresult",["unifiedpointer"]],["unifiedpointer"]]]],[5,"cuda_free","","Free memory allocated with `cuda_malloc`.",null,[[["devicepointer"]],["cudaresult"]]],[5,"cuda_free_unified","","Free memory allocated with `cuda_malloc_unified`.",null,[[["unifiedpointer"],["devicecopy"]],["cudaresult"]]],[5,"cuda_malloc_locked","","Unsafe wrapper around the `cuMemAllocHost` function, which…",null,[[["usize"]],["cudaresult"]]],[5,"cuda_free_locked","","Free page-locked memory allocated with `cuda_malloc_host`.",null,[[],["cudaresult"]]],[0,"array","","Routines for allocating and using CUDA Array Objects.",null,null],[3,"ArrayObjectFlags","rustacuda::memory::array","Flags which modify the behavior of CUDA array creation.",null,null],[3,"ArrayDescriptor","","Describes a CUDA Array",null,null],[3,"ArrayObject","","A CUDA Array. Can be bound to a texture or surface.",null,null],[4,"ArrayFormat","","Describes the format used for a CUDA Array.",null,null],[13,"UnsignedInt8","","Unsigned 8-bit integer",19,null],[13,"UnsignedInt16","","Unsigned 16-bit integer",19,null],[13,"UnsignedInt32","","Unsigned 32-bit integer",19,null],[13,"SignedInt8","","Signed 8-bit integer",19,null],[13,"SignedInt16","","Signed 16-bit integer",19,null],[13,"SignedInt32","","Signed 32-bit integer",19,null],[13,"Half","","Half-precision floating point number",19,null],[13,"Float","","Single-precision floating point number",19,null],[11,"from_raw","","Creates ArrayFormat from the CUDA Driver API enum",19,[[["cuarray_format"]],["self"]]],[11,"to_raw","","Converts ArrayFormat to the CUDA Driver API enum",19,[[],["cuarray_format"]]],[18,"LAYERED","","Enables creation of layered CUDA arrays. When this flag is…",20,null],[18,"SURFACE_LDST","","Enables surface references to be bound to the CUDA array.",20,null],[18,"CUBEMAP","","Enables creation of cubemaps. If this flag is set, Width…",20,null],[18,"TEXTURE_GATHER","","Indicates that the CUDA array will be used for texture…",20,null],[11,"empty","","Returns an empty set of flags",20,[[],["arrayobjectflags"]]],[11,"all","","Returns the set containing all flags.",20,[[],["arrayobjectflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",20,[[["self"]],["c_uint"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",20,[[["c_uint"]],[["option",["arrayobjectflags"]],["arrayobjectflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",20,[[["c_uint"]],["arrayobjectflags"]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",20,[[["c_uint"]],["arrayobjectflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",20,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",20,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",20,[[["self"],["arrayobjectflags"]]]],[11,"remove","","Removes the specified flags in-place.",20,[[["self"],["arrayobjectflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",20,[[["self"],["arrayobjectflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",20,[[["bool"],["self"],["arrayobjectflags"]]]],[11,"new","","Creates a default flags object with no flags set.",20,[[],["self"]]],[11,"from_raw","","Constructs an ArrayDescriptor from a CUDA Driver API Array…",21,[[["cuda_array3d_descriptor"]],["self"]]],[11,"new","","Constructs an ArrayDescriptor from dimensions, format,…",21,[[["arrayformat"],["arrayobjectflags"],["c_uint"]],["self"]]],[11,"from_dims_format","","Creates a new ArrayDescriptor from a set of dimensions and…",21,[[["arrayformat"]],["self"]]],[11,"dims","","Returns the dimensions of the ArrayDescriptor",21,[[["self"]]]],[11,"set_dims","","Sets the dimensions of the ArrayDescriptor",21,[[["self"]]]],[11,"width","","Returns the width of the ArrayDescripor",21,[[["self"]],["usize"]]],[11,"set_width","","Sets the width of the ArrayDescriptor",21,[[["self"],["usize"]]]],[11,"height","","Returns the height of the ArrayDescripor",21,[[["self"]],["usize"]]],[11,"set_height","","Sets the height of the ArrayDescriptor",21,[[["self"],["usize"]]]],[11,"depth","","Returns the depth of the ArrayDescripor",21,[[["self"]],["usize"]]],[11,"set_depth","","Sets the depth of the ArrayDescriptor",21,[[["self"],["usize"]]]],[11,"format","","Returns the format of the ArrayDescripor",21,[[["self"]],["arrayformat"]]],[11,"set_format","","Sets the format of the ArrayDescriptor",21,[[["arrayformat"],["self"]]]],[11,"num_channels","","Returns the number of channels in the ArrayDescriptor",21,[[["self"]],["c_uint"]]],[11,"set_num_channels","","Sets the number of channels in the ArrayDescriptor",21,[[["self"],["c_uint"]]]],[11,"flags","","Returns the flags of the ArrayDescriptor",21,[[["self"]],["arrayobjectflags"]]],[11,"set_flags","","Sets the flags of the ArrayDescriptor.",21,[[["self"],["arrayobjectflags"]]]],[11,"from_descriptor","","Constructs a generic ArrayObject from an `ArrayDescriptor`.",22,[[["arraydescriptor"]],["cudaresult"]]],[11,"new","","Allocates a new CUDA Array that is up to 3-dimensions.",22,[[["arrayformat"],["c_uint"]],["cudaresult"]]],[11,"new_1d","","Allocates a new 1D CUDA Array.",22,[[["arrayformat"],["usize"],["c_uint"]],["cudaresult"]]],[11,"new_2d","","Allocates a new CUDA Array that is up to 2-dimensions.",22,[[["arrayformat"],["c_uint"]],["cudaresult"]]],[11,"new_layered","","Creates a new Layered 1D or 2D CUDA Array.",22,[[["arrayformat"],["usize"],["c_uint"]],["cudaresult"]]],[11,"new_layered_1d","","Creates a new Layered 1D CUDA Array.",22,[[["arrayformat"],["usize"],["c_uint"]],["cudaresult"]]],[11,"new_cubemap","","Creates a new Cubemap CUDA Array. The array is represented…",22,[[["arrayformat"],["usize"],["c_uint"]],["cudaresult"]]],[11,"new_layered_cubemap","","Creates a new Layered Cubemap CUDA Array. The array is…",22,[[["arrayformat"],["usize"],["c_uint"]],["cudaresult"]]],[11,"descriptor","","Gets the descriptor associated with this array.",22,[[["self"]],[["cudaresult",["arraydescriptor"]],["arraydescriptor"]]]],[11,"drop","","Try to destroy an `ArrayObject`. Can fail - if it does,…",22,[[["arrayobject"]],[["dropresult",["arrayobject"]],["arrayobject"]]]],[11,"new","rustacuda::memory","Allocate device memory and place val into it.",23,[[["t"]],["cudaresult"]]],[11,"uninitialized","","Allocate device memory, but do not initialize it.",23,[[],["cudaresult"]]],[11,"zeroed","","Allocate device memory and fill it with zeroes (`0u8`).",23,[[],["cudaresult"]]],[11,"from_raw","","Constructs a DeviceBox from a raw pointer.",23,[[],["self"]]],[11,"from_device","","Constructs a DeviceBox from a DevicePointer.",23,[[["devicepointer"]],["self"]]],[11,"into_device","","Consumes the DeviceBox, returning the wrapped DevicePointer.",23,[[["devicebox"]],["devicepointer"]]],[11,"as_device_ptr","","Returns the contained device pointer without consuming the…",23,[[["self"]],["devicepointer"]]],[11,"drop","","Destroy a `DeviceBox`, returning an error.",23,[[["devicebox"]],[["devicebox"],["dropresult",["devicebox"]]]]],[11,"uninitialized","","Allocate a new device buffer large enough to hold `size`…",24,[[["usize"]],["cudaresult"]]],[11,"zeroed","","Allocate a new device buffer large enough to hold `size`…",24,[[["usize"]],["cudaresult"]]],[11,"from_raw_parts","","Creates a `DeviceBuffer<T>` directly from the raw…",24,[[["devicepointer"],["usize"]],["devicebuffer"]]],[11,"drop","","Destroy a `DeviceBuffer`, returning an error.",24,[[["devicebuffer"]],[["dropresult",["devicebuffer"]],["devicebuffer"]]]],[11,"from_slice","","Allocate a new device buffer of the same size as `slice`,…",24,[[],["cudaresult"]]],[11,"from_slice_async","","Asynchronously allocate a new buffer of the same size as…",24,[[["stream"]],["cudaresult"]]],[11,"len","","Returns the number of elements in the slice.",25,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the slice has a length of 0.",25,[[["self"]],["bool"]]],[11,"as_ptr","","Return a raw device-pointer to the slice's buffer.",25,[[["self"]]]],[11,"as_mut_ptr","","Returns an unsafe mutable device-pointer to the slice's…",25,[[["self"]]]],[11,"split_at","","Divides one DeviceSlice into two at a given index.",25,[[["self"],["usize"]]]],[11,"split_at_mut","","Divides one mutable DeviceSlice into two at a given index.",25,[[["self"],["usize"]]]],[11,"chunks","","Returns an iterator over `chunk_size` elements of the…",25,[[["self"],["usize"]],["devicechunks"]]],[11,"chunks_mut","","Returns an iterator over `chunk_size` elements of the…",25,[[["self"],["usize"]],["devicechunksmut"]]],[11,"as_device_ptr","","Returns a `DevicePointer<T>` to the buffer.",25,[[["self"]],["devicepointer"]]],[11,"from_raw_parts","","Forms a slice from a `DevicePointer` and a length.",25,[[["devicepointer"],["usize"]],["deviceslice"]]],[11,"from_raw_parts_mut","","Performs the same functionality as `from_raw_parts`,…",25,[[["devicepointer"],["usize"]],["deviceslice"]]],[11,"new","","Allocate a new page-locked buffer large enough to hold…",26,[[["t"],["usize"]],["cudaresult"]]],[11,"from_slice","","Allocate a new page-locked buffer of the same size as…",26,[[],["cudaresult"]]],[11,"uninitialized","","Allocate a new page-locked buffer large enough to hold…",26,[[["usize"]],["cudaresult"]]],[11,"as_slice","","Extracts a slice containing the entire buffer.",26,[[["self"]]]],[11,"as_mut_slice","","Extracts a mutable slice of the entire buffer.",26,[[["self"]]]],[11,"from_raw_parts","","Creates a `LockedBuffer<T>` directly from the raw…",26,[[["usize"]],["lockedbuffer"]]],[11,"drop","","Destroy a `LockedBuffer`, returning an error.",26,[[["lockedbuffer"]],[["dropresult",["lockedbuffer"]],["lockedbuffer"]]]],[11,"new","","Allocate unified memory and place val into it.",27,[[["t"]],["cudaresult"]]],[11,"uninitialized","","Allocate unified memory without initializing it.",27,[[],["cudaresult"]]],[11,"from_raw","","Constructs a UnifiedBox from a raw pointer.",27,[[],["self"]]],[11,"from_unified","","Constructs a UnifiedBox from a UnifiedPointer.",27,[[["unifiedpointer"]],["self"]]],[11,"into_unified","","Consumes the UnifiedBox, returning the wrapped…",27,[[["unifiedbox"]],["unifiedpointer"]]],[11,"as_unified_ptr","","Returns the contained unified pointer without consuming…",27,[[["self"]],["unifiedpointer"]]],[11,"leak","","Consumes and leaks the UnifiedBox, returning a mutable…",27,[[["unifiedbox"]],["t"]]],[11,"drop","","Destroy a `UnifiedBox`, returning an error.",27,[[["unifiedbox"]],[["unifiedbox"],["dropresult",["unifiedbox"]]]]],[11,"new","","Allocate a new unified buffer large enough to hold `size`…",28,[[["t"],["usize"]],["cudaresult"]]],[11,"from_slice","","Allocate a new unified buffer of the same size as `slice`,…",28,[[],["cudaresult"]]],[11,"uninitialized","","Allocate a new unified buffer large enough to hold `size`…",28,[[["usize"]],["cudaresult"]]],[11,"as_slice","","Extracts a slice containing the entire buffer.",28,[[["self"]]]],[11,"as_mut_slice","","Extracts a mutable slice of the entire buffer.",28,[[["self"]]]],[11,"as_unified_ptr","","Returns a `UnifiedPointer<T>` to the buffer.",28,[[["self"]],["unifiedpointer"]]],[11,"from_raw_parts","","Creates a `UnifiedBuffer<T>` directly from the raw…",28,[[["unifiedpointer"],["usize"]],["unifiedbuffer"]]],[11,"drop","","Destroy a `UnifiedBuffer`, returning an error.",28,[[["unifiedbuffer"]],[["unifiedbuffer"],["dropresult",["unifiedbuffer"]]]]],[8,"CopyDestination","","Sealed trait implemented by types which can be the source…",null,null],[10,"copy_from","","Copy data from `source`. `source` must be the same size as…",29,[[["self"],["o"]],["cudaresult"]]],[10,"copy_to","","Copy data to `dest`. `dest` must be the same size as `self`.",29,[[["o"],["self"]],["cudaresult"]]],[8,"AsyncCopyDestination","","Sealed trait implemented by types which can be the source…",null,null],[10,"async_copy_from","","Asynchronously copy data from `source`. `source` must be…",30,[[["self"],["stream"],["o"]],["cudaresult"]]],[10,"async_copy_to","","Asynchronously copy data to `dest`. `dest` must be the…",30,[[["o"],["self"],["stream"]],["cudaresult"]]],[0,"module","rustacuda","Functions and types for working with CUDA modules.",null,null],[3,"Module","rustacuda::module","A compiled CUDA module, loaded into a context.",null,null],[3,"Symbol","","Handle to a symbol defined within a CUDA module.",null,null],[11,"load_from_file","","Load a module from the given file name into the current…",31,[[["cstr"]],[["module"],["cudaresult",["module"]]]]],[11,"load_from_string","","Load a module from a CStr.",31,[[["cstr"]],[["module"],["cudaresult",["module"]]]]],[11,"get_global","","Get a reference to a global symbol, which can then be…",31,[[["self"],["cstr"]],[["cudaresult",["symbol"]],["symbol"]]]],[11,"get_function","","Get a reference to a kernel function which can then be…",31,[[["self"],["cstr"]],[["cudaresult",["function"]],["function"]]]],[11,"drop","","Destroy a `Module`, returning an error.",31,[[["module"]],[["module"],["dropresult",["module"]]]]],[0,"prelude","rustacuda","This module re-exports a number of commonly-used types for…",null,null],[3,"DeviceBuffer","rustacuda::prelude","Fixed-size device-side buffer. Provides basic access to…",null,null],[3,"UnifiedBuffer","","Fixed-size buffer in unified memory.",null,null],[8,"CopyDestination","","Sealed trait implemented by types which can be the source…",null,null],[10,"copy_from","","Copy data from `source`. `source` must be the same size as…",29,[[["self"],["o"]],["cudaresult"]]],[10,"copy_to","","Copy data to `dest`. `dest` must be the same size as `self`.",29,[[["o"],["self"]],["cudaresult"]]],[0,"stream","rustacuda","Streams of work for the device to perform.",null,null],[3,"StreamFlags","rustacuda::stream","Bit flags for configuring a CUDA Stream.",null,null],[3,"StreamWaitEventFlags","","Bit flags for configuring a CUDA Stream waiting on an CUDA…",null,null],[3,"Stream","","A stream of work for the device to perform.",null,null],[18,"DEFAULT","","No flags set.",32,null],[18,"NON_BLOCKING","","This stream does not synchronize with the NULL stream.",32,null],[11,"empty","","Returns an empty set of flags",32,[[],["streamflags"]]],[11,"all","","Returns the set containing all flags.",32,[[],["streamflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",32,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",32,[[["u32"]],[["option",["streamflags"]],["streamflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",32,[[["u32"]],["streamflags"]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",32,[[["u32"]],["streamflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",32,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",32,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",32,[[["self"],["streamflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",32,[[["self"],["streamflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",32,[[["self"],["streamflags"]]]],[11,"remove","","Removes the specified flags in-place.",32,[[["self"],["streamflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",32,[[["self"],["streamflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",32,[[["self"],["streamflags"],["bool"]]]],[18,"DEFAULT","","No flags set.",33,null],[11,"empty","","Returns an empty set of flags",33,[[],["streamwaiteventflags"]]],[11,"all","","Returns the set containing all flags.",33,[[],["streamwaiteventflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",33,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",33,[[["u32"]],[["streamwaiteventflags"],["option",["streamwaiteventflags"]]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",33,[[["u32"]],["streamwaiteventflags"]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",33,[[["u32"]],["streamwaiteventflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",33,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",33,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",33,[[["streamwaiteventflags"],["self"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",33,[[["streamwaiteventflags"],["self"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",33,[[["self"],["streamwaiteventflags"]]]],[11,"remove","","Removes the specified flags in-place.",33,[[["self"],["streamwaiteventflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",33,[[["self"],["streamwaiteventflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",33,[[["self"],["streamwaiteventflags"],["bool"]]]],[11,"new","","Create a new stream with the given flags and optional…",34,[[["option",["i32"]],["streamflags"],["i32"]],["cudaresult"]]],[11,"get_flags","","Return the flags which were used to create this stream.",34,[[["self"]],[["cudaresult",["streamflags"]],["streamflags"]]]],[11,"get_priority","","Return the priority of this stream.",34,[[["self"]],[["cudaresult",["i32"]],["i32"]]]],[11,"add_callback","","Add a callback to a stream.",34,[[["box"],["self"]],["cudaresult"]]],[11,"synchronize","","Wait until a stream's tasks are completed.",34,[[["self"]],["cudaresult"]]],[11,"wait_event","","Make the stream wait on an event.",34,[[["streamwaiteventflags"],["self"],["event"]],["cudaresult"]]],[11,"drop","","Destroy a `Stream`, returning an error.",34,[[["stream"]],[["dropresult",["stream"]],["stream"]]]],[11,"empty","rustacuda","Returns an empty set of flags",35,[[],["cudaflags"]]],[11,"all","","Returns the set containing all flags.",35,[[],["cudaflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",35,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",35,[[["u32"]],[["cudaflags"],["option",["cudaflags"]]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",35,[[["u32"]],["cudaflags"]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",35,[[["u32"]],["cudaflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",35,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",35,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",35,[[["cudaflags"],["self"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",35,[[["cudaflags"],["self"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",35,[[["self"],["cudaflags"]]]],[11,"remove","","Removes the specified flags in-place.",35,[[["self"],["cudaflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",35,[[["self"],["cudaflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",35,[[["self"],["cudaflags"],["bool"]]]],[11,"get","","Returns the latest CUDA version supported by the CUDA…",36,[[],[["cudaresult",["cudaapiversion"]],["cudaapiversion"]]]],[11,"major","","Return the major version number - eg. the 9 in version 9.2",36,[[],["i32"]]],[11,"minor","","Return the minor version number - eg. the 2 in version 9.2",36,[[],["i32"]]],[14,"launch","","Launch a kernel function asynchronously.",null,null],[11,"from","","",35,[[["t"]],["t"]]],[11,"into","","",35,[[],["u"]]],[11,"to_owned","","",35,[[["self"]],["t"]]],[11,"clone_into","","",35,[[["self"],["t"]]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"try_into","","",35,[[],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"type_id","","",35,[[["self"]],["typeid"]]],[11,"from","","",36,[[["t"]],["t"]]],[11,"into","","",36,[[],["u"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,[[["self"],["t"]]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"try_into","","",36,[[],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"type_id","","",36,[[["self"]],["typeid"]]],[11,"from","rustacuda::context","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,[[["self"],["t"]]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,[[["self"],["t"]]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"from","rustacuda::device","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,[[["self"],["t"]]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"into","","",37,[[],["u"]]],[11,"into_iter","","",37,[[],["i"]]],[11,"to_owned","","",37,[[["self"]],["t"]]],[11,"clone_into","","",37,[[["self"],["t"]]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"try_into","","",37,[[],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"type_id","","",37,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,[[["self"],["t"]]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"from","rustacuda::error","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,[[["self"],["t"]]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"from","rustacuda::event","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,[[["self"],["t"]]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,[[["self"],["t"]]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"from","rustacuda::function","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,[[["self"],["t"]]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,[[["self"],["t"]]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,[[["self"],["t"]]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"from","rustacuda::memory","",38,[[["t"]],["t"]]],[11,"into","","",38,[[],["u"]]],[11,"to_owned","","",38,[[["self"]],["t"]]],[11,"clone_into","","",38,[[["self"],["t"]]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"try_into","","",38,[[],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"type_id","","",38,[[["self"]],["typeid"]]],[11,"from","","",39,[[["t"]],["t"]]],[11,"into","","",39,[[],["u"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,[[["self"],["t"]]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"try_into","","",39,[[],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"type_id","","",39,[[["self"]],["typeid"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"into","","",24,[[],["u"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"type_id","","",24,[[["self"]],["typeid"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"type_id","","",25,[[["self"]],["typeid"]]],[11,"from","","",40,[[["t"]],["t"]]],[11,"into","","",40,[[],["u"]]],[11,"into_iter","","",40,[[],["i"]]],[11,"to_owned","","",40,[[["self"]],["t"]]],[11,"clone_into","","",40,[[["self"],["t"]]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"try_into","","",40,[[],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"type_id","","",40,[[["self"]],["typeid"]]],[11,"from","","",41,[[["t"]],["t"]]],[11,"into","","",41,[[],["u"]]],[11,"into_iter","","",41,[[],["i"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"try_into","","",41,[[],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"type_id","","",41,[[["self"]],["typeid"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"into","","",26,[[],["u"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"type_id","","",26,[[["self"]],["typeid"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"into","","",27,[[],["u"]]],[11,"to_string","","",27,[[["self"]],["string"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"type_id","","",27,[[["self"]],["typeid"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"into","","",28,[[],["u"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"try_into","","",28,[[],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"type_id","","",28,[[["self"]],["typeid"]]],[11,"from","rustacuda::memory::array","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,[[["self"],["t"]]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,[[["self"],["t"]]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,[[["self"],["t"]]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"from","rustacuda::module","",31,[[["t"]],["t"]]],[11,"into","","",31,[[],["u"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"try_into","","",31,[[],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"type_id","","",31,[[["self"]],["typeid"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"into","","",42,[[],["u"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"type_id","","",42,[[["self"]],["typeid"]]],[11,"from","rustacuda::stream","",32,[[["t"]],["t"]]],[11,"into","","",32,[[],["u"]]],[11,"to_owned","","",32,[[["self"]],["t"]]],[11,"clone_into","","",32,[[["self"],["t"]]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"try_into","","",32,[[],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"type_id","","",32,[[["self"]],["typeid"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"into","","",33,[[],["u"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,[[["self"],["t"]]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"try_into","","",33,[[],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"type_id","","",33,[[["self"]],["typeid"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"into","","",34,[[],["u"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"try_into","","",34,[[],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"type_id","","",34,[[["self"]],["typeid"]]],[11,"clone","rustacuda::memory","",39,[[["self"]],["unifiedpointer"]]],[11,"clone","","",38,[[["self"]],["devicepointer"]]],[11,"partial_cmp","","",38,[[["self"],["devicepointer"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","","",39,[[["self"],["unifiedpointer"]],[["option",["ordering"]],["ordering"]]]],[11,"cmp","","",38,[[["self"],["devicepointer"]],["ordering"]]],[11,"cmp","","",39,[[["self"],["unifiedpointer"]],["ordering"]]],[11,"hash","","",39,[[["self"],["h"]]]],[11,"hash","","",38,[[["self"],["h"]]]],[11,"eq","","",39,[[["self"],["unifiedpointer"]],["bool"]]],[11,"eq","","",38,[[["self"],["devicepointer"]],["bool"]]],[11,"fmt","","",39,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",38,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",39,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",38,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"get_inner","rustacuda::context","",5,[[["self"]],["cucontext"]]],[11,"get_inner","","",6,[[["self"]],["cucontext"]]],[11,"copy_from","rustacuda::memory","",23,[[["self"],["t"]],["cudaresult"]]],[11,"copy_to","","",23,[[["self"],["t"]],["cudaresult"]]],[11,"copy_from","","",23,[[["self"],["devicebox"]],["cudaresult"]]],[11,"copy_to","","",23,[[["devicebox"],["self"]],["cudaresult"]]],[11,"copy_from","","",25,[[["i"],["self"]],["cudaresult"]]],[11,"copy_to","","",25,[[["i"],["self"]],["cudaresult"]]],[11,"copy_from","","",25,[[["self"],["deviceslice"]],["cudaresult"]]],[11,"copy_to","","",25,[[["self"],["deviceslice"]],["cudaresult"]]],[11,"copy_from","","",25,[[["self"],["devicebuffer"]],["cudaresult"]]],[11,"copy_to","","",25,[[["self"],["devicebuffer"]],["cudaresult"]]],[11,"copy_from","rustacuda::module","",42,[[["self"],["t"]],["cudaresult"]]],[11,"copy_to","","",42,[[["self"],["t"]],["cudaresult"]]],[11,"async_copy_from","rustacuda::memory","",23,[[["self"],["devicebox"],["stream"]],["cudaresult"]]],[11,"async_copy_to","","",23,[[["devicebox"],["stream"],["self"]],["cudaresult"]]],[11,"async_copy_from","","",25,[[["i"],["self"],["stream"]],["cudaresult"]]],[11,"async_copy_to","","",25,[[["i"],["self"],["stream"]],["cudaresult"]]],[11,"async_copy_from","","",25,[[["self"],["deviceslice"],["stream"]],["cudaresult"]]],[11,"async_copy_to","","",25,[[["stream"],["self"],["deviceslice"]],["cudaresult"]]],[11,"async_copy_from","","",25,[[["self"],["devicebuffer"],["stream"]],["cudaresult"]]],[11,"async_copy_to","","",25,[[["stream"],["self"],["devicebuffer"]],["cudaresult"]]],[11,"drop","rustacuda::context","",5,[[["self"]]]],[11,"drop","rustacuda::event","",14,[[["self"]]]],[11,"drop","rustacuda::memory::array","",22,[[["self"]]]],[11,"drop","rustacuda::memory","",23,[[["self"]]]],[11,"drop","","",24,[[["self"]]]],[11,"drop","","",26,[[["self"]]]],[11,"drop","","",27,[[["self"]]]],[11,"drop","","",28,[[["self"]]]],[11,"drop","rustacuda::module","",31,[[["self"]]]],[11,"drop","rustacuda::stream","",34,[[["self"]]]],[11,"as_mut","rustacuda::memory","",26,[[["self"]]]],[11,"as_mut","","",27,[[["self"]],["t"]]],[11,"as_mut","","",28,[[["self"]]]],[11,"as_ref","","",26,[[["self"]]]],[11,"as_ref","","",27,[[["self"]],["t"]]],[11,"as_ref","","",28,[[["self"]]]],[11,"from","rustacuda::function","",15,[[["u32"]],["gridsize"]]],[11,"from","","",15,[[],["gridsize"]]],[11,"from","","",15,[[],["gridsize"]]],[11,"from","","",15,[[["gridsize"]],["gridsize"]]],[11,"from","","",16,[[["u32"]],["blocksize"]]],[11,"from","","",16,[[],["blocksize"]]],[11,"from","","",16,[[],["blocksize"]]],[11,"from","","",16,[[["blocksize"]],["blocksize"]]],[11,"next_back","rustacuda::memory","",40,[[["self"]],[["deviceslice"],["option",["deviceslice"]]]]],[11,"next_back","","",41,[[["self"]],[["deviceslice"],["option",["deviceslice"]]]]],[11,"extend","rustacuda::context","",4,[[["self"],["intoiterator"]]]],[11,"extend","rustacuda::event","",13,[[["self"],["intoiterator"]]]],[11,"extend","rustacuda::memory::array","",20,[[["self"],["intoiterator"]]]],[11,"extend","rustacuda::stream","",32,[[["self"],["intoiterator"]]]],[11,"extend","","",33,[[["intoiterator"],["self"]]]],[11,"extend","rustacuda","",35,[[["intoiterator"],["self"]]]],[11,"next","rustacuda::device","",37,[[["self"]],[["cudaresult",["device"]],["option",["cudaresult"]]]]],[11,"next","rustacuda::memory","",40,[[["self"]],[["deviceslice"],["option",["deviceslice"]]]]],[11,"size_hint","","",40,[[["self"]]]],[11,"count","","",40,[[],["usize"]]],[11,"nth","","",40,[[["self"],["usize"]],["option"]]],[11,"last","","",40,[[],["option"]]],[11,"next","","",41,[[["self"]],[["deviceslice"],["option",["deviceslice"]]]]],[11,"size_hint","","",41,[[["self"]]]],[11,"count","","",41,[[],["usize"]]],[11,"nth","","",41,[[["self"],["usize"]],["option"]]],[11,"last","","",41,[[],["option"]]],[11,"clone","rustacuda::context","",1,[[["self"]],["cacheconfig"]]],[11,"clone","","",2,[[["self"]],["resourcelimit"]]],[11,"clone","","",3,[[["self"]],["sharedmemoryconfig"]]],[11,"clone","","",4,[[["self"]],["contextflags"]]],[11,"clone","","",6,[[["self"]],["unownedcontext"]]],[11,"clone","","",0,[[["self"]],["streampriorityrange"]]],[11,"clone","rustacuda::device","",9,[[["self"]],["deviceattribute"]]],[11,"clone","","",10,[[["self"]],["device"]]],[11,"clone","","",37,[[["self"]],["devices"]]],[11,"clone","rustacuda::error","",11,[[["self"]],["cudaerror"]]],[11,"clone","rustacuda::event","",13,[[["self"]],["eventflags"]]],[11,"clone","","",12,[[["self"]],["eventstatus"]]],[11,"clone","rustacuda::function","",15,[[["self"]],["gridsize"]]],[11,"clone","","",16,[[["self"]],["blocksize"]]],[11,"clone","","",17,[[["self"]],["functionattribute"]]],[11,"clone","rustacuda::memory::array","",19,[[["self"]],["arrayformat"]]],[11,"clone","","",20,[[["self"]],["arrayobjectflags"]]],[11,"clone","","",21,[[["self"]],["arraydescriptor"]]],[11,"clone","rustacuda::memory","",40,[[["self"]],["devicechunks"]]],[11,"clone","rustacuda::stream","",32,[[["self"]],["streamflags"]]],[11,"clone","","",33,[[["self"]],["streamwaiteventflags"]]],[11,"clone","rustacuda","",35,[[["self"]],["cudaflags"]]],[11,"clone","","",36,[[["self"]],["cudaapiversion"]]],[11,"default","rustacuda::memory::array","",20,[[],["arrayobjectflags"]]],[11,"cmp","rustacuda::context","",4,[[["contextflags"],["self"]],["ordering"]]],[11,"cmp","rustacuda::event","",13,[[["eventflags"],["self"]],["ordering"]]],[11,"cmp","rustacuda::memory::array","",20,[[["self"],["arrayobjectflags"]],["ordering"]]],[11,"cmp","rustacuda::memory","",27,[[["unifiedbox"],["self"]],["ordering"]]],[11,"cmp","rustacuda::stream","",32,[[["streamflags"],["self"]],["ordering"]]],[11,"cmp","","",33,[[["self"],["streamwaiteventflags"]],["ordering"]]],[11,"cmp","rustacuda","",35,[[["cudaflags"],["self"]],["ordering"]]],[11,"cmp","","",36,[[["self"],["cudaapiversion"]],["ordering"]]],[11,"eq","rustacuda::context","",1,[[["self"],["cacheconfig"]],["bool"]]],[11,"eq","","",2,[[["resourcelimit"],["self"]],["bool"]]],[11,"eq","","",3,[[["self"],["sharedmemoryconfig"]],["bool"]]],[11,"eq","","",4,[[["contextflags"],["self"]],["bool"]]],[11,"ne","","",4,[[["contextflags"],["self"]],["bool"]]],[11,"eq","","",0,[[["self"],["streampriorityrange"]],["bool"]]],[11,"ne","","",0,[[["self"],["streampriorityrange"]],["bool"]]],[11,"eq","rustacuda::device","",9,[[["self"],["deviceattribute"]],["bool"]]],[11,"eq","","",10,[[["device"],["self"]],["bool"]]],[11,"ne","","",10,[[["device"],["self"]],["bool"]]],[11,"eq","rustacuda::error","",11,[[["self"],["cudaerror"]],["bool"]]],[11,"eq","rustacuda::event","",13,[[["eventflags"],["self"]],["bool"]]],[11,"ne","","",13,[[["eventflags"],["self"]],["bool"]]],[11,"eq","","",12,[[["self"],["eventstatus"]],["bool"]]],[11,"eq","rustacuda::function","",15,[[["gridsize"],["self"]],["bool"]]],[11,"ne","","",15,[[["gridsize"],["self"]],["bool"]]],[11,"eq","","",16,[[["self"],["blocksize"]],["bool"]]],[11,"ne","","",16,[[["self"],["blocksize"]],["bool"]]],[11,"eq","","",17,[[["self"],["functionattribute"]],["bool"]]],[11,"eq","rustacuda::memory::array","",19,[[["arrayformat"],["self"]],["bool"]]],[11,"eq","","",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"ne","","",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"eq","rustacuda::memory","",27,[[["unifiedbox"],["self"]],["bool"]]],[11,"eq","rustacuda::stream","",32,[[["streamflags"],["self"]],["bool"]]],[11,"ne","","",32,[[["streamflags"],["self"]],["bool"]]],[11,"eq","","",33,[[["self"],["streamwaiteventflags"]],["bool"]]],[11,"ne","","",33,[[["self"],["streamwaiteventflags"]],["bool"]]],[11,"eq","rustacuda","",35,[[["cudaflags"],["self"]],["bool"]]],[11,"ne","","",35,[[["cudaflags"],["self"]],["bool"]]],[11,"eq","","",36,[[["self"],["cudaapiversion"]],["bool"]]],[11,"ne","","",36,[[["self"],["cudaapiversion"]],["bool"]]],[11,"partial_cmp","rustacuda::context","",4,[[["contextflags"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",4,[[["contextflags"],["self"]],["bool"]]],[11,"le","","",4,[[["contextflags"],["self"]],["bool"]]],[11,"gt","","",4,[[["contextflags"],["self"]],["bool"]]],[11,"ge","","",4,[[["contextflags"],["self"]],["bool"]]],[11,"partial_cmp","rustacuda::event","",13,[[["eventflags"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",13,[[["eventflags"],["self"]],["bool"]]],[11,"le","","",13,[[["eventflags"],["self"]],["bool"]]],[11,"gt","","",13,[[["eventflags"],["self"]],["bool"]]],[11,"ge","","",13,[[["eventflags"],["self"]],["bool"]]],[11,"partial_cmp","rustacuda::memory::array","",20,[[["self"],["arrayobjectflags"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"le","","",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"gt","","",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"ge","","",20,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"partial_cmp","rustacuda::memory","",27,[[["unifiedbox"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",27,[[["unifiedbox"],["self"]],["bool"]]],[11,"le","","",27,[[["unifiedbox"],["self"]],["bool"]]],[11,"ge","","",27,[[["unifiedbox"],["self"]],["bool"]]],[11,"gt","","",27,[[["unifiedbox"],["self"]],["bool"]]],[11,"partial_cmp","rustacuda::stream","",32,[[["streamflags"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",32,[[["streamflags"],["self"]],["bool"]]],[11,"le","","",32,[[["streamflags"],["self"]],["bool"]]],[11,"gt","","",32,[[["streamflags"],["self"]],["bool"]]],[11,"ge","","",32,[[["streamflags"],["self"]],["bool"]]],[11,"partial_cmp","","",33,[[["self"],["streamwaiteventflags"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",33,[[["self"],["streamwaiteventflags"]],["bool"]]],[11,"le","","",33,[[["self"],["streamwaiteventflags"]],["bool"]]],[11,"gt","","",33,[[["self"],["streamwaiteventflags"]],["bool"]]],[11,"ge","","",33,[[["self"],["streamwaiteventflags"]],["bool"]]],[11,"partial_cmp","rustacuda","",35,[[["cudaflags"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",35,[[["cudaflags"],["self"]],["bool"]]],[11,"le","","",35,[[["cudaflags"],["self"]],["bool"]]],[11,"gt","","",35,[[["cudaflags"],["self"]],["bool"]]],[11,"ge","","",35,[[["cudaflags"],["self"]],["bool"]]],[11,"partial_cmp","","",36,[[["self"],["cudaapiversion"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",36,[[["self"],["cudaapiversion"]],["bool"]]],[11,"le","","",36,[[["self"],["cudaapiversion"]],["bool"]]],[11,"gt","","",36,[[["self"],["cudaapiversion"]],["bool"]]],[11,"ge","","",36,[[["self"],["cudaapiversion"]],["bool"]]],[11,"deref","rustacuda::memory","",24,[[["self"]],["deviceslice"]]],[11,"deref","","",26,[[["self"]]]],[11,"deref","","",27,[[["self"]],["t"]]],[11,"deref","","",28,[[["self"]]]],[11,"deref_mut","","",24,[[["self"]],["deviceslice"]]],[11,"deref_mut","","",26,[[["self"]]]],[11,"deref_mut","","",27,[[["self"]],["t"]]],[11,"deref_mut","","",28,[[["self"]]]],[11,"fmt","rustacuda::context","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",6,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",8,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::device","",9,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",10,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",37,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::error","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::event","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::function","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",16,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::memory::array","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory","",23,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",24,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",25,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",40,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",41,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",26,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",27,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",28,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::module","",31,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",42,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::stream","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::error","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::memory","",27,[[["formatter"],["self"]],["result"]]],[11,"sub","rustacuda::context","Returns the set difference of the two sets of flags.",4,[[["contextflags"]],["contextflags"]]],[11,"sub","rustacuda::event","Returns the set difference of the two sets of flags.",13,[[["eventflags"]],["eventflags"]]],[11,"sub","rustacuda::memory::array","Returns the set difference of the two sets of flags.",20,[[["arrayobjectflags"]],["arrayobjectflags"]]],[11,"sub","rustacuda::stream","Returns the set difference of the two sets of flags.",32,[[["streamflags"]],["streamflags"]]],[11,"sub","","Returns the set difference of the two sets of flags.",33,[[["streamwaiteventflags"]],["streamwaiteventflags"]]],[11,"sub","rustacuda","Returns the set difference of the two sets of flags.",35,[[["cudaflags"]],["cudaflags"]]],[11,"sub_assign","rustacuda::context","Disables all flags enabled in the set.",4,[[["self"],["contextflags"]]]],[11,"sub_assign","rustacuda::event","Disables all flags enabled in the set.",13,[[["self"],["eventflags"]]]],[11,"sub_assign","rustacuda::memory::array","Disables all flags enabled in the set.",20,[[["self"],["arrayobjectflags"]]]],[11,"sub_assign","rustacuda::stream","Disables all flags enabled in the set.",32,[[["self"],["streamflags"]]]],[11,"sub_assign","","Disables all flags enabled in the set.",33,[[["self"],["streamwaiteventflags"]]]],[11,"sub_assign","rustacuda","Disables all flags enabled in the set.",35,[[["self"],["cudaflags"]]]],[11,"not","rustacuda::context","Returns the complement of this set of flags.",4,[[],["contextflags"]]],[11,"not","rustacuda::event","Returns the complement of this set of flags.",13,[[],["eventflags"]]],[11,"not","rustacuda::memory::array","Returns the complement of this set of flags.",20,[[],["arrayobjectflags"]]],[11,"not","rustacuda::stream","Returns the complement of this set of flags.",32,[[],["streamflags"]]],[11,"not","","Returns the complement of this set of flags.",33,[[],["streamwaiteventflags"]]],[11,"not","rustacuda","Returns the complement of this set of flags.",35,[[],["cudaflags"]]],[11,"bitand","rustacuda::context","Returns the intersection between the two sets of flags.",4,[[["contextflags"]],["contextflags"]]],[11,"bitand","rustacuda::event","Returns the intersection between the two sets of flags.",13,[[["eventflags"]],["eventflags"]]],[11,"bitand","rustacuda::memory::array","Returns the intersection between the two sets of flags.",20,[[["arrayobjectflags"]],["arrayobjectflags"]]],[11,"bitand","rustacuda::stream","Returns the intersection between the two sets of flags.",32,[[["streamflags"]],["streamflags"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",33,[[["streamwaiteventflags"]],["streamwaiteventflags"]]],[11,"bitand","rustacuda","Returns the intersection between the two sets of flags.",35,[[["cudaflags"]],["cudaflags"]]],[11,"bitor","rustacuda::context","Returns the union of the two sets of flags.",4,[[["contextflags"]],["contextflags"]]],[11,"bitor","rustacuda::event","Returns the union of the two sets of flags.",13,[[["eventflags"]],["eventflags"]]],[11,"bitor","rustacuda::memory::array","Returns the union of the two sets of flags.",20,[[["arrayobjectflags"]],["arrayobjectflags"]]],[11,"bitor","rustacuda::stream","Returns the union of the two sets of flags.",32,[[["streamflags"]],["streamflags"]]],[11,"bitor","","Returns the union of the two sets of flags.",33,[[["streamwaiteventflags"]],["streamwaiteventflags"]]],[11,"bitor","rustacuda","Returns the union of the two sets of flags.",35,[[["cudaflags"]],["cudaflags"]]],[11,"bitxor","rustacuda::context","Returns the left flags, but with all the right flags…",4,[[["contextflags"]],["contextflags"]]],[11,"bitxor","rustacuda::event","Returns the left flags, but with all the right flags…",13,[[["eventflags"]],["eventflags"]]],[11,"bitxor","rustacuda::memory::array","Returns the left flags, but with all the right flags…",20,[[["arrayobjectflags"]],["arrayobjectflags"]]],[11,"bitxor","rustacuda::stream","Returns the left flags, but with all the right flags…",32,[[["streamflags"]],["streamflags"]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",33,[[["streamwaiteventflags"]],["streamwaiteventflags"]]],[11,"bitxor","rustacuda","Returns the left flags, but with all the right flags…",35,[[["cudaflags"]],["cudaflags"]]],[11,"bitand_assign","rustacuda::context","Disables all flags disabled in the set.",4,[[["self"],["contextflags"]]]],[11,"bitand_assign","rustacuda::event","Disables all flags disabled in the set.",13,[[["self"],["eventflags"]]]],[11,"bitand_assign","rustacuda::memory::array","Disables all flags disabled in the set.",20,[[["self"],["arrayobjectflags"]]]],[11,"bitand_assign","rustacuda::stream","Disables all flags disabled in the set.",32,[[["self"],["streamflags"]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",33,[[["self"],["streamwaiteventflags"]]]],[11,"bitand_assign","rustacuda","Disables all flags disabled in the set.",35,[[["self"],["cudaflags"]]]],[11,"bitor_assign","rustacuda::context","Adds the set of flags.",4,[[["self"],["contextflags"]]]],[11,"bitor_assign","rustacuda::event","Adds the set of flags.",13,[[["self"],["eventflags"]]]],[11,"bitor_assign","rustacuda::memory::array","Adds the set of flags.",20,[[["self"],["arrayobjectflags"]]]],[11,"bitor_assign","rustacuda::stream","Adds the set of flags.",32,[[["self"],["streamflags"]]]],[11,"bitor_assign","","Adds the set of flags.",33,[[["self"],["streamwaiteventflags"]]]],[11,"bitor_assign","rustacuda","Adds the set of flags.",35,[[["self"],["cudaflags"]]]],[11,"bitxor_assign","rustacuda::context","Toggles the set of flags.",4,[[["self"],["contextflags"]]]],[11,"bitxor_assign","rustacuda::event","Toggles the set of flags.",13,[[["self"],["eventflags"]]]],[11,"bitxor_assign","rustacuda::memory::array","Toggles the set of flags.",20,[[["self"],["arrayobjectflags"]]]],[11,"bitxor_assign","rustacuda::stream","Toggles the set of flags.",32,[[["self"],["streamflags"]]]],[11,"bitxor_assign","","Toggles the set of flags.",33,[[["self"],["streamwaiteventflags"]]]],[11,"bitxor_assign","rustacuda","Toggles the set of flags.",35,[[["self"],["cudaflags"]]]],[11,"index","rustacuda::memory","",25,[[["range",["usize"]],["self"],["usize"]],["self"]]],[11,"index","","",25,[[["self"],["rangefull"]],["self"]]],[11,"index","","",25,[[["usize"],["self"],["rangefrom",["usize"]]],["self"]]],[11,"index","","",25,[[["rangeinclusive",["usize"]],["self"],["usize"]],["self"]]],[11,"index","","",25,[[["rangeto",["usize"]],["self"],["usize"]],["self"]]],[11,"index","","",25,[[["usize"],["self"],["rangetoinclusive",["usize"]]],["self"]]],[11,"index_mut","","",25,[[["self"],["range",["usize"]],["usize"]],["self"]]],[11,"index_mut","","",25,[[["self"],["rangefull"]],["self"]]],[11,"index_mut","","",25,[[["self"],["rangefrom",["usize"]],["usize"]],["self"]]],[11,"index_mut","","",25,[[["self"],["usize"],["rangeinclusive",["usize"]]],["self"]]],[11,"index_mut","","",25,[[["self"],["rangeto",["usize"]],["usize"]],["self"]]],[11,"index_mut","","",25,[[["self"],["rangetoinclusive",["usize"]],["usize"]],["self"]]],[11,"hash","rustacuda::context","",1,[[["self"],["__h"]]]],[11,"hash","","",2,[[["self"],["__h"]]]],[11,"hash","","",3,[[["self"],["__h"]]]],[11,"hash","","",4,[[["self"],["__h"]]]],[11,"hash","","",0,[[["self"],["__h"]]]],[11,"hash","rustacuda::device","",9,[[["self"],["__h"]]]],[11,"hash","","",10,[[["self"],["__h"]]]],[11,"hash","rustacuda::event","",13,[[["self"],["__h"]]]],[11,"hash","rustacuda::function","",17,[[["self"],["__h"]]]],[11,"hash","rustacuda::memory::array","",20,[[["self"],["__h"]]]],[11,"hash","rustacuda::memory","",27,[[["self"],["h"]]]],[11,"hash","rustacuda::stream","",32,[[["self"],["__h"]]]],[11,"hash","","",33,[[["self"],["__h"]]]],[11,"hash","rustacuda","",35,[[["self"],["__h"]]]],[11,"hash","","",36,[[["self"],["__h"]]]],[11,"from_iter","rustacuda::context","",4,[[["intoiterator"]],["contextflags"]]],[11,"from_iter","rustacuda::event","",13,[[["intoiterator"]],["eventflags"]]],[11,"from_iter","rustacuda::memory::array","",20,[[["intoiterator"]],["arrayobjectflags"]]],[11,"from_iter","rustacuda::stream","",32,[[["intoiterator"]],["streamflags"]]],[11,"from_iter","","",33,[[["intoiterator"]],["streamwaiteventflags"]]],[11,"from_iter","rustacuda","",35,[[["intoiterator"]],["cudaflags"]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::event","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::event","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::event","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::event","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory","",23,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",27,[[["formatter"],["self"]],["result"]]],[11,"fmt","rustacuda::module","",42,[[["formatter"],["self"]],["result"]]],[11,"borrow","rustacuda::memory","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"wrap","","Wrap the given raw pointer in a DevicePointer. The given…",38,[[],["devicepointer"]]],[11,"as_raw","","Returns the contained pointer as a raw pointer. The…",38,[[]]],[11,"as_raw_mut","","Returns the contained pointer as a mutable raw pointer.…",38,[[["self"]]]],[11,"is_null","","Returns true if the pointer is null. # Examples",38,[[],["bool"]]],[11,"null","","Returns a null device pointer.",38,[[],["devicepointer"]]],[11,"offset","","Calculates the offset from a device pointer.",38,[[["isize"]],["devicepointer"]]],[11,"wrapping_offset","","Calculates the offset from a device pointer using wrapping…",38,[[["isize"]],["devicepointer"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",38,[[["usize"]],["devicepointer"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",38,[[["usize"]],["devicepointer"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",38,[[["usize"]],["devicepointer"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",38,[[["usize"]],["devicepointer"]]],[11,"wrap","","Wrap the given raw pointer in a UnifiedPointer. The given…",39,[[],["unifiedpointer"]]],[11,"as_raw","","Returns the contained pointer as a raw pointer.",39,[[]]],[11,"as_raw_mut","","Returns the contained pointer as a mutable raw pointer.",39,[[["self"]]]],[11,"is_null","","Returns true if the pointer is null.",39,[[],["bool"]]],[11,"null","","Returns a null unified pointer.",39,[[],["unifiedpointer"]]],[11,"offset","","Calculates the offset from a unified pointer.",39,[[["isize"]],["unifiedpointer"]]],[11,"wrapping_offset","","Calculates the offset from a unified pointer using…",39,[[["isize"]],["unifiedpointer"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",39,[[["usize"]],["unifiedpointer"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",39,[[["usize"]],["unifiedpointer"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",39,[[["usize"]],["unifiedpointer"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",39,[[["usize"]],["unifiedpointer"]]]],"p":[[3,"StreamPriorityRange"],[4,"CacheConfig"],[4,"ResourceLimit"],[4,"SharedMemoryConfig"],[3,"ContextFlags"],[3,"Context"],[3,"UnownedContext"],[3,"ContextStack"],[3,"CurrentContext"],[4,"DeviceAttribute"],[3,"Device"],[4,"CudaError"],[4,"EventStatus"],[3,"EventFlags"],[3,"Event"],[3,"GridSize"],[3,"BlockSize"],[4,"FunctionAttribute"],[3,"Function"],[4,"ArrayFormat"],[3,"ArrayObjectFlags"],[3,"ArrayDescriptor"],[3,"ArrayObject"],[3,"DeviceBox"],[3,"DeviceBuffer"],[3,"DeviceSlice"],[3,"LockedBuffer"],[3,"UnifiedBox"],[3,"UnifiedBuffer"],[8,"CopyDestination"],[8,"AsyncCopyDestination"],[3,"Module"],[3,"StreamFlags"],[3,"StreamWaitEventFlags"],[3,"Stream"],[3,"CudaFlags"],[3,"CudaApiVersion"],[3,"Devices"],[3,"DevicePointer"],[3,"UnifiedPointer"],[3,"DeviceChunks"],[3,"DeviceChunksMut"],[3,"Symbol"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);